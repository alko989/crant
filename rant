#!/bin/bash
# Build on all platforms and verify everything works properly. This is basically
# like doexport with a few additional commands.
# TODO: Add submit to CRAN
# ftp://cran.r-project.org/incoming and send email to cran@r-project.org
version=1.0.0
builddate=$(date +%F)
host_windows=192.168.1.46
upgrade_version=
export=export

fatal()
{
  [ -n "$2" ] && echo "$2" >> /dev/stderr
  exit $1
}

check_fatal()
{
  exitcode=$?
  [ $exitcode -eq 0 ] || fatal $exitcode "$1"
}


do_build()
{
  $R CMD build $binary $package
  [ -z "$nocheck" ] && $R CMD check $package_src
  [ -n "$docran" ] && $R CMD check --as-cran $package_src


  if [[ -z "$binary" && -n "$windows" ]]
  then
    # Try building on Windows if not on Windows (is that contradictory ;)
    echo "Attempting to build Windows package"
    set -x
    cmd_env='source ~/.bashrc; cd $WORKSPACE'
    cmd_rant="rant -v $version -d $builddate -b $package"
    ssh $host_windows "$cmd_env; $cmd_rant"
    set +x
  fi
}

do_export()
{
  # No need for binary here, since windows packages are built manually
  $R CMD build $resavedata $package
  # The built source package is all they want here
  #tar jcf ${package}_${version}.src.tbz2 $package

  # Upload to CRAN
  #TODO: Do this
}

set_windows_path()
{
  # This can be cleaned up more
  if [ -z "$RANT" ]
  then
    RANT="/c/Program Files (x86)/MiKTeX 2.7/miktex/bin:/c/Rtools/bin:/c/Rtools/perl/bin:/c/Rtools/MinGW/bin"
    export PATH=$RANT:$PATH
  fi
  echo "Using PATH=$PATH"
}

# Export to the export directory
do_repo_export()
{
  rm -rf $export/$package > /dev/null 2>&1
  mkdir $export >> /dev/null 2>&1
  if [ -n "$noscm" ]
  then
    cp -R "$package_basename" $export/
    rm -rf $export/$package/{.svn,.git,.gitignore,.Rproj.user} >> /dev/null 2>&1
  elif [ -d "$package_basename/.svn" ]
  then
    svn export "$package_basename" $export/$package
  elif [ -d "$package_basename/.git" ]
  then
    mkdir -p $export/$package
    (cd "$package_basename" && git archive master) | tar -x -C $export/$package
  else
    cp -$R "$package_basename" $export/
  fi
  cd $export
}

read_package_name()
{
  package_name=$(sed -n -r "/^Package:/{s/^Package:[ \t]+([^ \t]+)[ \t]*$/\1/;p}" "$package_basename"/DESCRIPTION)
  [ -z "$package_name" ] && fatal 2 "Cannot determine package name. Do you have a properly formatted DESCRIPTION file?"
  echo -n "$package_name"
}

do_bind_package()
{
  files='"$package_basename"/DESCRIPTION "$package_basename"/R/$package-package.R "$package_basename"/man/$package-package.Rd'
  [ -n "$version" ] && sed -i -r "
    s/(Version: ([\\]tab |))([0-9.-]+|\{version\})/\1$version/;
    s/(Date: ([\\]tab |))([0-9-]+|\{date\})/\1$builddate/
  " $files 2>/dev/null
}

do_roxygenize()
{
  if [ -n "$roxygen" ]; then
    printf "Roxygenizing %s\n" $package
    echo "library(roxygen2); roxygenize('"$package_basename"')" | $R --vanilla
    [ -n "$roxystop" ] && exit 0
  fi
}

get_current_version()
{
  sed -n -r "/^Version: /{s/^Version:[ \t]+([^ \t]+)[ \t]*$/\1/;p}" "$package_basename"/DESCRIPTION
}

do_upgrade_version()
{
  pos=$1
  current_version=$(get_current_version)
  cva=($(echo -n $current_version | sed -r "s/([0-9]+)([-.])([0-9]+)($|([-.])([0-9]+)($|([-.])([0-9]+)))/\1 \2 \3 \5 \6 \8 \9/"))
  cvaz=($(echo -n "${cva[*]}" | sed -r "s/[0-9]+/0/g"))
  case $pos in
  1) echo $((${cva[0]} + 1))${cvaz[1]}${cvaz[2]}${cvaz[3]}${cvaz[4]}${cvaz[5]}${cvaz[6]};;
  2) echo ${cva[0]}${cva[1]}$((${cva[2]} + 1))${cvaz[3]}${cvaz[4]}${cvaz[5]}${cvaz[6]};;
  3) if [ -n "${cva[4]}" ]; then echo ${cva[0]}${cva[1]}${cva[2]}${cva[3]}$((${cva[4]} + 1))${cvaz[5]}${cvaz[6]};
     else echo "Warning: Invalid parameter $pos to -u switch" > /dev/stderr; fi;;
  4) if [ -n "${cva[6]}" ]; then echo ${cva[0]}${cva[1]}${cva[2]}${cva[3]}${cva[4]}${cva[5]}$((${cva[6]} + 1));
     else echo "Warning: Invalid parameter $pos to -u switch" > /dev/stderr; fi;;
  *) echo "Warning: Invalid parameter $pos to -u switch" > /dev/stderr;;
  esac
}

R=R
while getopts "v:Vd:R:DCrSiebwh:xXu:?" opt
do
  case $opt in
  v) version=$OPTARG;;
  V) version=;;
  d) builddate=$OPTARG;;
  R) R=$OPTARG;;
  D) resavedata=--resave-data;;
  C) nocheck=1;;
  r) docran=1; nocheck=1;;
  S) noscm=1;;
  i) doinstall=1;;
  e) doexport=1;;
  b) binary="--binary";; # For windows
  w) windows=1;;
  h) windows=1; host_windows=$OPTARG;;
  x) roxygen=1;;
  X) roxygen=1; roxystop=1;;
  u) upgrade_version=$OPTARG;;
  ?) printf "Usage: %s: [-e] [-v version] [-d date] [path/to/package]\n" $0
     exit 2;;
  esac
done
shift $(($OPTIND - 1))

package_dir=$1
[ -z "$package_dir" ] && package_dir=.
package_dir=$(readlink -f "$package_dir")

[ "$package_dir" = "/" ] && fatal 4 "Cannot run for root directory."

package_dirname=$(dirname $package_dir)
package_basename=$(basename $package_dir)

cd "$package_dirname"

package=$(read_package_name)
check_fatal

if [ -n "$upgrade_version" ]; then
  version=$(do_upgrade_version $upgrade_version)
fi

if [ -z "$version" ]; then
  version=$(get_current_version)
fi

package_src=${package}_${version}.tar.gz

do_bind_package
do_roxygenize

[ -z "$doexport" ] && printf "Running build chain on %s\n" $package
[ -n "$doexport" ] && printf "Running export on %s\n" $package

# In windows, get the latest source
if [ -n "$binary" ]
then
  set_windows_path
  cd $package
  svn update
  cd -
fi

do_repo_export

[ -z "$doexport" ] && do_build
[ -n "$doexport" ] && do_export
cd -

if [ -n "$doinstall" ]
then
  echo "Installing package $package"
  $R CMD INSTALL $export/$package_src
fi

echo "Done with package $package"
